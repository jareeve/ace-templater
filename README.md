# firefly-assembly-engine-lib

[![Build Status](https://travis.ibm.com/Cloud-Integration/firefly-assembly-engine-lib.svg?token=dumtP4qs4gsJwe4mVisv&branch=master)](https://travis.ibm.com/Cloud-Integration/firefly-assembly-engine-lib)

This library has the function to retrieve flow / integration assemblies and execute them. Used within firefly-flow-engine and loopback-modelapi-provider

There is a Jenkins build that creates the firefly-assembly-engine-lib package [here](https://appcon-jenkins.swg-devops.com/view/All/job/firefly-assembly-engine-lib/)

---

## Configuration Parameters

If your application uses this library, then the following configuration parameters are **required** environment variables:
 - FIREFLY_AUTH_ISSUER
 - FIREFLY_AUTH_JWT_PUB_KEY
 - MH_API_KEY
 - MH_PASS
 - MH_REST_URL
 - MH_USER

If your application uses this library, then the following configuration parameters are **optional** environment variables:
 - FIREFLY_FEATURE_TOGGLES
 - IBM_ALERT_NOTIFICATION_PASSWORD
 - IBM_ALERT_NOTIFICATION_URL
 - IBM_ALERT_NOTIFICATION_USER
 - METRICS_MH_TOPIC
 - USE_IBM_ALERT_NOTIFICATION

## Available nodes:
 - [`if`](#if)
 - [`create-action`](#create-action)
 - [`retrieve-action`](#retrieve-action)
 - [`upsert-action`](#upsert-action)
 - [`response`](#response)
 - [`aync-batch`](#aync-batch)
 
### <a name="if">`if`</a> 

The `if` node contains a list of conditions to evaluate. Each condition is evaluated in turn until one evaluates to true and then an assosicated subflow of nodes is executed. 
Only the first matching condition will have it's subflow executed but it would be simple in the future to add options to allow all matching conditions to execute. 
If no conditions match then a default subflow is executed (and if that is left out then processing would just continue to the next node).
Once the subflow has finished processing then a map is executed to map the data generated in the `if` block back to the flow containing the `if`. Any modifications made to the assembly context 
while in an `if` block are deleted when the node finishes executing except for the data mapped out at the end of processing. The if node can contain any other nodes within the subflows it executes including nesting other `if`s.
The node properties look like:
```json
{
  "if":
  {
    "name": "if_1",
    "input":[
      {
        "variable": "Request",
        "$ref": "#/trigger/payload"
      },
      {  
        "variable": "$SalesforceCreateCustomer",
        "$ref": "#/node-output/Salesforce Create Customer/response/payload "
      }
    ],
    "branch": [
      {
        "condition": {"{{SalesforceCreateCustomer.title}} {{$Request.firstname}} {{$Request.lastname}}": "Dr John Reeve"},
        "execute": [],
        "completion-action": "abortWithError",
        "error": {
          "input":[
            {
              "variable": "Request",
              "$ref": "#/trigger/payload"
            }],
            message: "Failed to calculate customer {{SalesforceCreateCustomer.title}} {{$Request.firstname}} {{$Request.lastname}} tax return.",
            status-code: "500"
        },
        "map":{}
      }
    ],
    "else": {
      "execute": [],
      "map": {},
      "completion-action": "continue"
    },
    "output-schema": {
      "properties":{
        "field1": {"type": "string"}
      }
    }
  }
}
```
The properties are used as follows:
* `name` - a unique name for the `if` block within the integration.
* `input` - the input sources to be used in any jsonata evaluation with in the case conditions. Any maps will have there own input sources defined.
* `branch` - a list of rules to execute the conditions for. The first rule to evaluate it's `condition` to true (hit) will then execute all the nodes in `execute` property.
 Once the list of nodes in the execute has finished successfully then the action in `completion-action` is done. If the action is to `continue`
  (or `completion-action` is not specified) then the `map` is executed to copy values back into the `node-output` section of the assembly. The flow then proceeds 
  to the next node to execute. If the `completion-action` is `abortWithError` then the `error` object is used to construct an error 
  to return to any calling application. The `error/message` is logged using a generic message that has one insert and no other text 
  and the flow processing is terminated. 
  
* `else` - if no rules in the banch array hit then the all the nodes in `else`'s' property `execute` are executed followed by the same processing as the branch defined above.
* `output-schema` - a definition of the data generated by the `if` node after it has finished processing a branch. This is the schema that each `map` on each `branc`h maps to.

### Syntax for the `condition` expression.
The `condition` clause for each case is based on the loopback where syntax but with the left had side of any expressions being a jsonata template rather than an actual field name.
The following `where` like syntax will be supported:

    1, Simple equal:
    
```json
{ 
    "{{$SalesforceCreateCustomer.title}} {{$Request.firstname}} {{$Request.lastname}}": "Dr John Reeve"
}  
```

   2, Simple `and` with equals:
	
```json
{ 
  "and":[{"{{firstName}}": "John"}, {"{{lastName}}": "reeve"} ]
}  
```

   3, Simple `or` with equals:
	
```json
{ 
  "or":[{"{{lastName}}": "hosie"}, {"{{lastName}}": "reeve"} ]
}  
```

Note: if the user wants to just execute a single jsonata expression to see if it is true they can us ethe following:
```json
{ 
    "{{$Request.lastname='reeve'}}": "true"
} 
```

### Mechanism for managing `if` branches in the assembly context.
When entering an 'if' node it generates a new section in the assembly context under `branch` called the name of the node. 
This section has one called `node-output`. Any node that executes while in the branch writes it's output to the `node-output` section'. Any embeded `if` node that gets executed gets added to the branch section.
When the `if` node finished executing the whole section defined by the node name is deleted from the assembly context.
For example:
1, Entering `if_1`:
```json
 {
   "branch":
     {
       "if_1":{
         "level": 1,
         "node-output": {}
       }
 }
```
2, After `create-action`:
```json
 {
   "branch":
     {
       "if_1":{
         "level": 1,
         "node-output": {
           "Create Salesforce Customer 7": {
             "response": {
               "status-code": 200,
               "payload": {"field1": "value1" }
             }
           }
         }
       }
     }
 }
```
3, After entering `if_2`:
```json
 {
   "branch":
     {
       "if_1":{
         "level": 1,
         "node-output": {
           "Create Salesforce Customer 7": {
             "response": {
               "status-code": 200,
               "payload": {"field1": "value1" }
             }
           }
         }
       },
       "if_2":{
         "level": 2,
         "node-output": {}
       }
     }
 }
```
3, Leaving `if_2`, no node-output in `if_2` so just add in empty section in node `if_` for it:
```json
  {
    "branch":
      {
        "if_1":{
         "level": 1,
          "node-output": {
            "Create Salesforce Customer 7": {
              "response": {
                "status-code": 200,
                "payload": {"field1": "value1"}
              }
            },
            {
              "if_2":{
              "response": {
                "status-code": 200,
                "payload": {}
              }
            }
          }
        }
      }
  }
```
4, Leaving `if_1` and map back data from create. In this case the map directly mapped all the info back:
```json
  {
    "node-output" 
      "if_1":{
         "response": {
           "status-code": 200,
           "payload": {"field1": "value1}
        }
     },
    "branch": {}
  }
```

### <a name="retrieve-action">`retrieve-action`</a>

The [`retrieve-action`](./lib/nodes/retrieve-action/retrieve-action.js) node is used to call the loopback connector to do a retrieve on an end system.
For first story it is limited to retrieving only one doc. If no docs or several docs are retrieved then the flow is failed with an error stating what the issue was.
The node properties look like:
```json
{
  "retrieve-action":
  {
    "name": "Salesforce Retrieve Customer",
    "target": { "$ref": "#/flow/connector-configuration/target/interaction/interactionTarget2"},
    "filter": {
      "input":[
        {
          "variable": "Request",
	      "$ref": "#/trigger/payload"
        }
      ],
      "where": { 
        "fullName": "{{$Request.firstname}} {{$Request.lastname}}"
      }  
    }
  }
}
```
The properties are used as follows:
* `name` - the name of the node and used as the location to write the retrieved doc to in the assembly context.
* `target` - a reference to the action interface to make the retrieve against.
* <a name="retrieveFilter">`filter`</a>:
    * `input` - a set of variables setup to point to well known locations in the assembly conext. Used by any jsonata expressions to access the assembly context data.
    * `where` - the loop back filter expression. For first story it will be limited to one of the following:
    1, Simple equal:
    
```json
{
  "where": { 
    "fullName": "{{$Request.firstname}} {{$Request.lastname}}"  
  }  
}
```

   2, Simple `and` with equals:
	
```json
{
  "where": { 
    "and":[{"fullName": "John"}, {"lastName": "reeve"} ]
  }
}
```

It will be very simple to extend this as needed to cover more complex where syntax.

The `retrieve-action` node will url encode the  json `filter` expression and make a get call to the connector.

### <a name="create-action"> `create-action `</a>

The [`create-action`](./lib/nodes/create-action/create-action.js) node is used to call the loopback connector to do a create in an end system.
The result of the create is written to the output-node section of the assembly context.
```json
{
                    "create-action": {
                      "name": "TransformAndRequest",
                      "target": {
                        "$ref": "#/flow/connector-configuration/target/interaction/interactionTarget2"
                      },
                      "map": {
                        "mappings": [
                          {
                            "CompleteName": {
                              "template":  "{{LastName}}"
                            }
                          }
                        ]
                      }
                    }
                  }
```
The properties are used as follows:
* `name` - the name of the node and used as the location to write the created doc to in the assembly context.
* `target` - a reference to the action interface to make the retrieve against.
* `map` - a map to map from the message assembly to the object to create in the end system.

### <a name="upsert-action">`upsert-action`</a>
The [`upsert-action`](./lib/nodes/upsert-action/upsert-action.js) node is used to call the loopback connector to do an upsert on an end system. 
It is up to the connector being called to generate any errors that occur for the filter matching more than one doc to update (or any other issues with the filter data). 
The node properties look like:
```json
{
  "upsert-action":
  {
    "name": "Salesforce Upsert Customer",
    "target": { "$ref": "#/flow/connector-configuration/target/interaction/interactionTarget2"},
    "filter": {
      "input":[
        {
          "variable": "Request",
	       "$ref": "#/trigger/payload"
        }
      ],
      "where": { 
        "fullName": "{{$Request.firstname}} {{$Request.lastname}}"
      }  
    },
    "map": {
      "input":[
            {
              "variable": "Request",
               "$ref": "#/trigger/payload"
            }
        ],
       "mappings": [
          {
            "fullName": {
              "template":  "{{$Request.firstname}} {{$Request.lastname}}
            },
            "address": {
              "template":  "{{$Request.address}}"
            }
          }
        ]
      }
  }
}
```
The properties are used as follows:
* `name` - the name of the node and used as the location to write the upsert result into the assembly context.
* `target` - a reference to the action interface to make the upsert against.
* `filter` - same syntax as the [retrieve node filter](#retrieveFilter). 
* `map` - a map to map from the message assembly to the object to create/update in the end system.

It will be very simple to extend this as needed to cover more complex where syntax.

The `upsert-action` node will url encode the  json `filter` expression and make a post call to the connector containing the result of the map as the body.
The assembly context will be updated after the upsert action with the returned payload from the connector and a field signaling 
if a create (return code 201) or update was done (return code ???). For example:
- for create:
```
 "node-output": {
   "Upsert Salesforce Customer": {
     "response": {
       "status-code": 201,
       "payload": {"id": "1515155151" }
     }
   }
 }
```
- for update:
```
 "node-output": {
   "Upsert Salesforce Customer": {
     "response": {
       "status-code": 200,
       "payload": {"id": "1515155151" }
     }
   }
 }
```
Not sure if we should have an extra field as well as status code to signal if it was created or updated? For example:
```
 "node-output": {
   "Upsert Salesforce Customer": {
     "response": {
       "status-code": 201,
       "created": true,
       "payload": {"id": "1515155151" }
     }
   }
 }
```

###  <a name="response">response</a>

The [`response`](./lib/nodes/response/response.js) node is used construct a response to send back from the flow.
```json
{
    "response":
    {
        "name": "response-1", 
        "reply-maps":
        [
            {
                "title": "Contact successfully created",
                "status-code": 204,
                "map": {
                    "$map": lib,

                    "mappings": [
                        {
                            "LastName": {
                                "template": "{{$source1.LastName}}"
                            },
                            "LastName2": {
                                "template": "{{LastName}}"
                            },
                            "Id": {
                                "template": "{{$source2.id}}"
                            }
                        }
                    ],
                    "input": [{
                        "$ref": "#/trigger/payload",
                        "variable": "source1"
                    }, {
                        "$ref": "#/node-output/node 1/response/payload",
                        "variable": "source2"
                    }]
                }
            }
        ]
    }
}
```
The properties are used as follows:
* `name` - the name of the node and used as the location to write the created doc to in the assembly context.
* `reply-maps` - an array of maps to map from the assembly context to the response for the flow. Currenlty, only the first map will be executed in the list but in future mechanism to select a map will be added (like a jsonata condition)
    * `title` - title of a particular response map. Used in the ui to define the meaning of each map.
    * `status-code` - the status code to put into the response.
    * `map` - the map to execute to generate the response.


### <a name="aync-batch">`async-batch`</a>
TODO: need to doc
    
# API Documentation

(An example of the API usage can be found in the [component tests](./test-component/component-test.js))

## FlowInstanceManager
The FlowInstanceManager is used to retrieve the flow/integration assemblies from the runtime flow service and constructs a FlowInstance.

```
var flowManager = new FlowInstanceManager(*route_to_runtime*);
```
### FlowInstanceManager.getFlowInstances
Promise to get an array of FlowInstances based on assemblySelector

assemblySelector can be either;
- { "stream-id": "streamId"};
- {"flow-id": "flowId", "assembly-id": "assemblyId"};
```
flowManager.getFlowInstances(assemblySelector);
```

## FlowInstance
A FlowInstance is used to execute an assembly

### FlowInstance.trigger
Promise to execute the flow and return the result based on options
```
{
  payload: payload from trigger/api call
  invocationId: global transaction ID
  api: any extra api information that does not belong in payload
  event: any extra event information that does not belong in payload
  batch: api: any extra batch information that does not belong in payload
}
```
```
flowInstance.trigger(options)
```
The promise resolves with the following structure when flow finishes successfully:
```
{
  "status-code": 204,
  "payload": {LastName: "reeve", "Id": "12345"}
}
                
```
and rejects with error if the flow fails to work.
# ace-templater
